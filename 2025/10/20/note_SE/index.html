<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>软件工程笔记 | Baihua&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="王老师软件工程课笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程笔记">
<meta property="og:url" content="http://example.com/2025/10/20/note_SE/index.html">
<meta property="og:site_name" content="Baihua&#39;Blog">
<meta property="og:description" content="王老师软件工程课笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/IMG_20231209_163913.jpg">
<meta property="article:published_time" content="2025-10-20T11:15:00.397Z">
<meta property="article:modified_time" content="2025-10-20T15:17:07.516Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/IMG_20231209_163913.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Baihua'Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Baihua&#39;Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-note_SE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/20/note_SE/" class="article-date">
  <time class="dt-published" datetime="2025-10-20T11:15:00.397Z" itemprop="datePublished">2025-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      软件工程笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>王老师软件工程课笔记</p>
<span id="more"></span>
<h1>Part I 绪论</h1>
<h2 id="1、软件危机的定义">1、软件危机的定义</h2>
<ul>
<li>
<p>软件规模增长，复杂度增加，导致超预算、完成脱期、质量下降。</p>
</li>
<li>
<p>可靠性随规模增长而下降。</p>
</li>
</ul>
<h2 id="2、软件危机的成因">2、软件危机的成因</h2>
<ul>
<li>
<p>维护费用急剧上升，占软件总费用的大部分，包括纠错性维护、适应性维护和完善性维护。</p>
</li>
<li>
<p>软件技术进步缓慢；软件复杂度增长，而生产方式仍是手工；早期个人自由化开发的软件难以维护。</p>
</li>
</ul>
<h2 id="3、软件工程的范畴">3、软件工程的范畴</h2>
<ul>
<li>
<p>软件开发技术：包括开发方法学、开发工具、软件工程环境。</p>
</li>
<li>
<p>软件工程管理：包括软件管理学、软件度量学、软件经济学。</p>
</li>
</ul>
<h2 id="4、3种编程范式">4、3种编程范式</h2>
<ol>
<li>
<p>过程式编程范式：程序 = 数据结构 + 算法，自顶向下逐步求精，如<br>
Pascal，难以维护。</p>
</li>
<li>
<p>面向对象编程范式：数据及操作封装于对象中，强调对象与消息。</p>
</li>
<li>
<p>基于构件技术的编程范型：通用的可复用组件，支持跨平台运行。</p>
</li>
</ol>
<h2 id="5、三代软件工程的区别">5、三代软件工程的区别</h2>
<ol>
<li>
<p><strong>传统软件工程</strong>：结构化分析、结构化设计、面向过程编码与测试。</p>
</li>
<li>
<p><strong>面向对象的软件工程</strong>：OO<br>
分析、对象提取、详细设计、面向对象编码与测试。</p>
</li>
<li>
<p><strong>基于构件的软件工程</strong>：领域分析、构件设计、建立可复用构件库，按构件集成模型开发。</p>
</li>
</ol>
<h1>Part II 生命周期与过程</h1>
<h2 id="1、软件生命周期">1、软件生命周期</h2>
<p>软件从立项开始到废止为止，大致分为计划、开发和运行三个时期。</p>
<p>典型的软件生存周期包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求分析 → 软件分析 → 软件设计 → 编码 → 测试 → 运行维护</span><br></pre></td></tr></table></figure>
<h2 id="2、传统软件过程模型">2、传统软件过程模型</h2>
<h3 id="瀑布模型（Waterfall-Model）">瀑布模型（Waterfall Model）</h3>
<ul>
<li>
<p>阶段顺序执行，前一阶段完成后才能进入下一阶段。</p>
</li>
<li>
<p>各阶段有明确输出，作为下一阶段输入。</p>
</li>
<li>
<p>推迟实现：逻辑设计与物理实现分离。</p>
</li>
<li>
<p>质量保证：每个阶段需编写文档并复审。</p>
</li>
</ul>
<h3 id="快速原型模型（Prototyping-Model）">快速原型模型（Prototyping Model）</h3>
<ul>
<li>
<p>先建立一个符合用户初步需求的原型系统。</p>
</li>
<li>
<p>用户通过原型明确需求，开发者根据反馈改进。</p>
</li>
<li>
<p>是获取真实需求的一种有效方法。</p>
</li>
</ul>
<h3 id="增量模型（Incremental-Model）">增量模型（Incremental Model）</h3>
<ul>
<li>
<p>瀑布模型与快速原型模型的结合。</p>
</li>
<li>
<p>软件被划分为多个增量，每个增量独立完成开发。</p>
</li>
<li>
<p>每次迭代交付一个可运行的子系统。</p>
</li>
</ul>
<h3 id="螺旋模型（Spiral-Model）">螺旋模型（Spiral Model）</h3>
<ul>
<li>
<p>在瀑布模型和快速原型模型基础上演变而来。</p>
</li>
<li>
<p>每个周期包含：计划 → 风险分析 → 建立原型 → 用户评审。</p>
</li>
<li>
<p>适用于大型复杂软件项目。</p>
</li>
</ul>
<h3 id="构件集成模型（Component-Integration-Model）">构件集成模型（Component Integration Model）</h3>
<ul>
<li>
<p>将数据和操作封装为对象，称为&quot;类&quot;。</p>
</li>
<li>
<p>设计和实现的类可作为构件，具有通用性和复用性。</p>
</li>
<li>
<p>构件存入构件库，供后续开发使用。</p>
</li>
</ul>
<h2 id="3、构件集成模型的特点">3、构件集成模型的特点</h2>
<ol>
<li>
<p>使用预先封装好的构件来构造应用软件系统。</p>
</li>
<li>
<p>融合了螺旋模型的特性，支持迭代开发。</p>
</li>
<li>
<p>软件开发与构件开发可并行进行，主要用于面向对象开发。</p>
</li>
</ol>
<h2 id="4、统一过程（RUP）">4、统一过程（RUP）</h2>
<p>统一过程（Rational Unified Process）是一种迭代式软件开发过程。</p>
<h3 id="四个阶段：">四个阶段：</h3>
<ul>
<li>
<p><strong>初始阶段</strong>：判定项目是否可行。</p>
</li>
<li>
<p><strong>细化阶段</strong>：用例细化、风险分析、生成系统框架。</p>
</li>
<li>
<p><strong>构造阶段</strong>：识别剩余用例，进行迭代开发与质量检测。</p>
</li>
<li>
<p><strong>迁移阶段</strong>：验收产品，制作用户文档，部署上线。</p>
</li>
</ul>
<p>每个阶段分为若干次迭代，每次迭代包含多个工作流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求 → 分析 → 设计 → 实现 → 测试 → 维护</span><br></pre></td></tr></table></figure>
<h2 id="5、软件可行性研究">5、软件可行性研究</h2>
<ul>
<li>
<p><strong>目的</strong>：判断待开发项目是否值得进行。</p>
</li>
<li>
<p><strong>内容</strong>：包括经济可行性、技术可行性、运行可行性和法律可行性。</p>
</li>
</ul>
<h1>Part III 结构化分析与设计</h1>
<h2 id="1、结构化分析与设计的任务">1、结构化分析与设计的任务</h2>
<ul>
<li>
<p>建立系统的分析模型。</p>
</li>
<li>
<p>编写《软件需求规格说明书》。</p>
</li>
</ul>
<h2 id="2、结构化分析的指导思想">2、结构化分析的指导思想</h2>
<ul>
<li>
<p><strong>抽象</strong>：忽略与目标无关的细节，提取关键特征。</p>
</li>
<li>
<p><strong>分解</strong>：将复杂系统分解为若干子系统，逐步细化。</p>
</li>
</ul>
<h2 id="3、SA模型的构成">3、SA模型的构成</h2>
<p>结构化分析（SA）模型以 <strong>数据字典</strong> 为核心，主要包括：</p>
<ul>
<li>
<p><strong>实体联系图（ER图）</strong>：描述数据对象及其关系。</p>
</li>
<li>
<p><strong>数据流图（DFD）</strong>：描述系统中数据的流动和处理过程。</p>
</li>
<li>
<p><strong>状态转换图（STD）</strong>：描述系统状态的变化及控制逻辑。</p>
</li>
</ul>
<h3 id="数据流图（DFD）基本符号">数据流图（DFD）基本符号</h3>
<ul>
<li>
<p>圆框：表示加工（处理）。</p>
</li>
<li>
<p>方框：表示数据源点或终点。</p>
</li>
<li>
<p>箭头：表示数据流向。</p>
</li>
<li>
<p>双杠：表示数据文件或数据库。</p>
</li>
</ul>
<h2 id="4、SD模型的结构">4、SD模型的结构</h2>
<p>结构化设计（SD）模型包括以下四个方面：</p>
<ul>
<li>
<p><strong>体系结构设计</strong>：定义系统的整体结构。</p>
</li>
<li>
<p><strong>接口设计</strong>：定义模块之间的接口。</p>
</li>
<li>
<p><strong>过程设计</strong>：定义每个模块的算法逻辑。</p>
</li>
<li>
<p><strong>数据设计</strong>：定义数据结构。</p>
</li>
</ul>
<h2 id="5、从DFD图到SC图的过程">5、从DFD图到SC图的过程</h2>
<ul>
<li>
<p><strong>变换型结构</strong>：由传入路径、变换中心和传出路径组成。</p>
</li>
<li>
<p><strong>事务型结构</strong>：包含一条接受路径、一个事务中心和若干条动作路径。</p>
</li>
</ul>
<h2 id="6、优化SC图的原则">6、优化SC图的原则</h2>
<ol>
<li>
<p>合理划分模块，保持模块独立性。</p>
</li>
<li>
<p>遵循&quot;高扇入，低扇出&quot;的原则。</p>
</li>
</ol>
<h2 id="7、模块设计与结构化设计的关系">7、模块设计与结构化设计的关系</h2>
<ul>
<li>
<p>模块设计是结构化设计的细化。</p>
</li>
<li>
<p>目的是为SC图中的每个模块确定算法和内部数据结构。</p>
</li>
<li>
<p>使用合适的表达工具（如流程图、N-S图）进行描述。</p>
</li>
</ul>
<h2 id="8、模块设计的原则和方法">8、模块设计的原则和方法</h2>
<ul>
<li>
<p>清晰第一的设计风格。</p>
</li>
<li>
<p>使用结构化的控制结构（顺序、选择、循环）。</p>
</li>
<li>
<p>采用逐步细化的实现方法。</p>
</li>
</ul>
<h2 id="9、流程图与N-S图">9、流程图与N-S图</h2>
<ul>
<li>
<p><strong>流程图</strong>：用菱形表示判定，箭头表示控制流向。</p>
</li>
<li>
<p><strong>N-S图</strong>（纳-萨图）：用矩形框表示控制结构，无箭头，结构更清晰。</p>
</li>
</ul>
<h1>Part IV 面向对象与UML</h1>
<h2 id="1、面向对象的基本特征">1、面向对象的基本特征</h2>
<p>面向对象方法的核心特征包括：</p>
<ul>
<li>
<p><strong>抽象</strong>：提取对象的共性，忽略与当前目标无关的细节。</p>
</li>
<li>
<p><strong>封装</strong>：将数据与操作封装在对象内部，隐藏实现细节。</p>
</li>
<li>
<p><strong>继承</strong>：子类继承父类的属性和方法，实现代码复用。</p>
</li>
<li>
<p><strong>多态</strong>：同一操作作用于不同对象时表现出不同的行为。</p>
</li>
</ul>
<h2 id="2、UML图的分类">2、UML图的分类</h2>
<p>UML（统一建模语言）图分为两大类：</p>
<h3 id="静态图（结构图）">静态图（结构图）</h3>
<ul>
<li>
<p>用例图（Use Case Diagram）</p>
</li>
<li>
<p>类图（Class Diagram）</p>
</li>
<li>
<p>对象图（Object Diagram）</p>
</li>
<li>
<p>构件图（Component Diagram）</p>
</li>
<li>
<p>部署图（Deployment Diagram）</p>
</li>
</ul>
<h3 id="动态图（行为图）">动态图（行为图）</h3>
<ul>
<li>
<p>状态图（State Diagram）</p>
</li>
<li>
<p>活动图（Activity Diagram）</p>
</li>
<li>
<p>时序图（Sequence Diagram）</p>
</li>
<li>
<p>协作图（Collaboration Diagram）</p>
</li>
</ul>
<h2 id="3、UML视图">3、UML视图</h2>
<p>UML提供了多种视图，用于从不同角度描述系统：</p>
<ul>
<li>
<p><strong>用例视图</strong>：描述系统功能需求。</p>
</li>
<li>
<p><strong>逻辑视图</strong>：描述系统内部的逻辑结构。</p>
</li>
<li>
<p><strong>进程视图</strong>：描述系统的并发和同步机制。</p>
</li>
<li>
<p><strong>构件视图</strong>：描述系统的物理构件组织。</p>
</li>
<li>
<p><strong>部署视图</strong>：描述系统在物理节点上的部署情况。</p>
</li>
</ul>
<h2 id="4、UML的应用">4、UML的应用</h2>
<p>UML广泛应用于软件开发的各个阶段：</p>
<ul>
<li>
<p>描述系统需求（用例图）。</p>
</li>
<li>
<p>建立静态模型（类图、对象图）。</p>
</li>
<li>
<p>描述系统行为（状态图、活动图、时序图）。</p>
</li>
</ul>
<h2 id="5、用例图与用例模型">5、用例图与用例模型</h2>
<h3 id="参与者（Actor）">参与者（Actor）</h3>
<p>指与系统交互的外部实体，可以是人或其他系统。</p>
<h3 id="用例（Use-Case）">用例（Use Case）</h3>
<p>表示系统提供的一个完整功能，通常是一个业务流程。</p>
<h3 id="用例规约">用例规约</h3>
<p>对用例的详细描述，包括前置条件、后置条件、主事件流、备选事件流等。</p>
<h3 id="用例之间的关系">用例之间的关系</h3>
<ul>
<li>
<p><strong>包含关系（include）</strong>：一个用例包含另一个用例的行为。</p>
</li>
<li>
<p><strong>扩展关系（extend）</strong>：一个用例在特定条件下扩展另一个用例。</p>
</li>
<li>
<p><strong>泛化关系（generalization）</strong>：子用例继承父用例的行为。</p>
</li>
</ul>
<h2 id="6、动态建模">6、动态建模</h2>
<h3 id="时序图（Sequence-Diagram）">时序图（Sequence Diagram）</h3>
<ul>
<li>
<p>描述对象之间的交互顺序。</p>
</li>
<li>
<p>强调消息发送的时间顺序。</p>
</li>
</ul>
<h3 id="协作图（Collaboration-Diagram）">协作图（Collaboration Diagram）</h3>
<ul>
<li>
<p>描述对象之间的交互关系。</p>
</li>
<li>
<p>强调对象之间的链接和消息传递。</p>
</li>
</ul>
<h3 id="区别">区别</h3>
<ul>
<li>
<p>时序图强调时间顺序。</p>
</li>
<li>
<p>协作图强调对象之间的结构关系和交互链接。</p>
</li>
</ul>
<h1>Part V 需求工程与需求分析</h1>
<h2 id="1、什么是需求">1、什么是需求</h2>
<p>需求是软件系统必须满足的条件或能力，包括：</p>
<ul>
<li>
<p><strong>用户需求</strong>：用户为达成特定目标所期望的系统功能。</p>
</li>
<li>
<p><strong>业务需求</strong>：组织或客户为实现业务目标所需的功能。</p>
</li>
<li>
<p><strong>功能需求</strong>：系统必须提供的具体功能。</p>
</li>
<li>
<p><strong>非功能需求</strong>：如性能、安全性、可靠性、可用性等。</p>
</li>
</ul>
<p>需求通常以合同、规范、说明书等形式明确下来。</p>
<h2 id="2、需求工程（Requirements-Engineering）">2、需求工程（Requirements Engineering）</h2>
<p>需求工程是指采用有效的技术和方法，使用合适的工具和符号，对目标系统的需求进行：</p>
<ul>
<li>
<p>获取</p>
</li>
<li>
<p>分析</p>
</li>
<li>
<p>描述</p>
</li>
<li>
<p>验证</p>
</li>
<li>
<p>管理</p>
</li>
</ul>
<p>其目标是确保开发出满足用户真实需求的软件系统。</p>
<h2 id="3、需求分析的步骤">3、需求分析的步骤</h2>
<p>需求分析通常包括以下几个步骤：</p>
<ol>
<li>
<p><strong>需求获取</strong>：通过与用户交流、调研、观察等方式收集需求。</p>
</li>
<li>
<p><strong>需求建模</strong>：使用模型（如用例图、ER图、DFD图）对需求进行抽象和描述。</p>
</li>
<li>
<p><strong>需求描述</strong>：编写《软件需求规格说明书》（SRS）。</p>
</li>
<li>
<p><strong>需求验证</strong>：检查需求的完整性、一致性、可行性和可验证性。</p>
</li>
<li>
<p><strong>需求管理</strong>：对需求变更进行控制与跟踪。</p>
</li>
</ol>
<h2 id="4、软件需求规格说明书（SRS）">4、软件需求规格说明书（SRS）</h2>
<p>SRS 是需求分析阶段的主要文档，内容包括：</p>
<ul>
<li>
<p>功能需求</p>
</li>
<li>
<p>非功能需求</p>
</li>
<li>
<p>系统接口</p>
</li>
<li>
<p>用户界面</p>
</li>
<li>
<p>数据需求</p>
</li>
<li>
<p>运行环境</p>
</li>
<li>
<p>假设与依赖</p>
</li>
</ul>
<p>SRS 是后续设计、开发、测试和验收的依据。</p>
<h2 id="5、需求分析的目标">5、需求分析的目标</h2>
<ul>
<li>
<p>明确系统必须做什么。</p>
</li>
<li>
<p>为系统设计提供基础。</p>
</li>
<li>
<p>为项目验收提供标准。</p>
</li>
<li>
<p>降低开发风险，避免需求变更带来的成本增加。</p>
</li>
</ul>
<h1>Part VI 面向对象分析</h1>
<h2 id="1-面向对象分析的核心">1 面向对象分析的核心</h2>
<p>面向对象分析（OOA）以 <strong>用例模型</strong> 为主体，建立以下三类模型：</p>
<ul>
<li>
<p><strong>类-对象模型</strong>：描述系统静态结构。</p>
</li>
<li>
<p><strong>对象-关系模型</strong>：描述对象之间的关联、依赖、泛化等关系。</p>
</li>
<li>
<p><strong>对象-行为模型</strong>：描述对象的动态行为、状态变化及交互过程。</p>
</li>
</ul>
<h2 id="2-分析类的三种原型">2 分析类的三种原型</h2>
<p>根据职责不同，将分析阶段识别的类划分为三种原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">负责系统与外部参与者之间的交互，如 GUI、API、打印接口等。</span><br><span class="line"></span><br><span class="line">封装一个用例或一项业务流程的控制逻辑，协调边界类与实体类完成特定任务。</span><br><span class="line"></span><br><span class="line">表示系统中长期存在的信息及相关行为，通常对应业务实体，需持久化存储。</span><br></pre></td></tr></table></figure>
<h2 id="3-分析过程概要">3 分析过程概要</h2>
<ol>
<li>
<p>根据用例图识别参与者和用例。</p>
</li>
<li>
<p>为每个用例绘制时序图（或协作图），确定消息流与所需对象。</p>
</li>
<li>
<p>从时序图中提取边界类、控制类、实体类。</p>
</li>
<li>
<p>建立类图：定义类属性、操作及类间关系（关联、泛化、依赖）。</p>
</li>
<li>
<p>建立状态图（可选）：描述实体类对象的生命周期。</p>
</li>
<li>
<p>持续验证模型与需求的一致性，迭代求精。</p>
</li>
</ol>
<h2 id="4-类-对象模型示例要素">4 类-对象模型示例要素</h2>
<ul>
<li>
<p>类名：名词，首字母大写；尽可能使用业务术语。</p>
</li>
<li>
<p>属性：类所维护的信息，可见性可暂时省略。</p>
</li>
<li>
<p>操作：从用例行为或消息序列中抽象出的职责。</p>
</li>
<li>
<p>关系：</p>
<ul>
<li>
<p>关联（Association）：对象间的连接，可注明多重性。</p>
</li>
<li>
<p>泛化（Generalization）：继承关系，子类继承父类特征。</p>
</li>
<li>
<p>依赖（Dependency）：临时、单向使用关系。</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-对象-行为模型补充">5 对象-行为模型补充</h2>
<ul>
<li>
<p>用 <strong>状态图</strong> 描述单个实体类对象的状态转换事件。</p>
</li>
<li>
<p>用 <strong>活动图</strong> 描述用例或控制类的业务流程。</p>
</li>
<li>
<p>用 <strong>时序图</strong>/<strong>协作图</strong> 细化对象间交互顺序与消息。</p>
</li>
</ul>
<h2 id="6-分析阶段交付物">6 分析阶段交付物</h2>
<ul>
<li>
<p>用例模型（用例图 + 用例规约）。</p>
</li>
<li>
<p>类图（含边界类、控制类、实体类及其关系）。</p>
</li>
<li>
<p>关键动态图（时序图、状态图、活动图）。</p>
</li>
<li>
<p>分析模型说明书（可选，用于正式评审）。</p>
</li>
</ul>
<h1>Part VII 面向对象设计</h1>
<h2 id="1-设计目标">1 设计目标</h2>
<p>面向对象设计（OOD）在分析模型基础上，定义：</p>
<ul>
<li>
<p>如何构造系统；</p>
</li>
<li>
<p>如何组织类与对象；</p>
</li>
<li>
<p>如何满足非功能需求（性能、复用、可扩展、可维护等）。</p>
</li>
</ul>
<h2 id="2-模块与信息隐藏">2 模块与信息隐藏</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">具有明确定义的输入、输出和功能的程序实体，如类、包、构件。</span><br><span class="line"></span><br><span class="line">模块内部数据与实现细节对外不可见，仅通过公共接口访问。</span><br></pre></td></tr></table></figure>
<h2 id="3-模块独立性度量">3 模块独立性度量</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">衡量模块内部元素彼此结合的紧密程度。\</span><br><span class="line">理想：功能内聚 \&gt; 顺序内聚 \&gt; 通信内聚 \&gt; 过程内聚 \&gt; 时间内聚 \&gt;</span><br><span class="line">逻辑内聚 \&gt; 偶然内聚。</span><br><span class="line"></span><br><span class="line">衡量模块之间相互关联的强度。\</span><br><span class="line">理想：非直接耦合 \&lt; 数据耦合 \&lt; 标记耦合 \&lt; 控制耦合 \&lt; 外部耦合 \&lt;</span><br><span class="line">公共耦合 \&lt; 内容耦合。</span><br></pre></td></tr></table></figure>
<h2 id="4-设计任务总览">4 设计任务总览</h2>
<p>面向对象设计分为两大层次：</p>
<h3 id="4-1-系统架构设计">4.1 系统架构设计</h3>
<ol>
<li>
<p><strong>高层架构设计</strong>：选择分层、MVC、微服务、客户端/服务器等总体结构。</p>
</li>
<li>
<p><strong>确定设计元素</strong>：将分析类映射为设计类、包、子系统、构件。</p>
</li>
<li>
<p><strong>任务管理策略</strong>：多线程/进程模型、并发控制、事务策略。</p>
</li>
<li>
<p><strong>分布式机制</strong>：远程方法调用、消息队列、服务发现等。</p>
</li>
<li>
<p><strong>数据存储方案</strong>：关系数据库、对象-关系映射、NoSQL、文件系统。</p>
</li>
<li>
<p><strong>人机界面设计</strong>：界面框架、交互流程、可视化控件选型。</p>
</li>
</ol>
<h3 id="4-2-系统元素详细设计">4.2 系统元素详细设计</h3>
<ol>
<li>
<p><strong>类/对象设计</strong>：细化属性、操作签名、可见性、算法框架；应用设计模式。</p>
</li>
<li>
<p><strong>子系统设计</strong>：定义子系统接口与协作契约，降低耦合。</p>
</li>
<li>
<p><strong>包设计</strong>：按功能、层次、复用原则划分包，控制包间依赖。</p>
</li>
</ol>
<h2 id="5-类设计常用原则">5 类设计常用原则</h2>
<ul>
<li>
<p>单一职责原则（SRP）：一个类只负责一项职责。</p>
</li>
<li>
<p>开闭原则（OCP）：对扩展开放，对修改关闭。</p>
</li>
<li>
<p>里氏代换原则（LSP）：子类应能替换父类而不影响正确性。</p>
</li>
<li>
<p>依赖倒置原则（DIP）：依赖抽象，而非具体实现。</p>
</li>
<li>
<p>接口隔离原则（ISP）：客户端不应被迫依赖不用的接口。</p>
</li>
</ul>
<h2 id="6-设计模式速览">6 设计模式速览</h2>
<ul>
<li>
<p><strong>创建型</strong>：Singleton、Factory Method、Abstract<br>
Factory、Builder、Prototype。</p>
</li>
<li>
<p><strong>结构型</strong>：Adapter、Bridge、Composite、Decorator、Facade、Flyweight、Proxy。</p>
</li>
<li>
<p><strong>行为型</strong>：Observer、Strategy、Template<br>
Method、Command、Iterator、State 等。</p>
</li>
</ul>
<p>在详细设计阶段，可借助模式提高复用性与可维护性。</p>
<h2 id="7-设计模型交付物">7 设计模型交付物</h2>
<ul>
<li>
<p>细化类图（属性、操作、可见性、设计模式标注）。</p>
</li>
<li>
<p>包图与子系统图（层次、接口、依赖）。</p>
</li>
<li>
<p>关键动态图（时序图、协作图、状态图、活动图）。</p>
</li>
<li>
<p>数据模型（类-表映射、ORM 配置、索引策略）。</p>
</li>
<li>
<p>界面原型与交互说明（可选）。</p>
</li>
<li>
<p>《软件设计说明书》（SDS）。</p>
</li>
</ul>
<h1>Part VIII 编码与测试</h1>
<h2 id="1-编码原则">1 编码原则</h2>
<ul>
<li>
<p>清晰第一：程序应易于阅读与理解。</p>
</li>
<li>
<p>简洁直接：避免过度技巧与冗余逻辑。</p>
</li>
<li>
<p>遵循团队编码规范（命名、缩进、注释、文件组织）。</p>
</li>
<li>
<p>持续重构：保持代码&quot;坏味道&quot;最低。</p>
</li>
</ul>
<h2 id="2-测试基本概念">2 测试基本概念</h2>
<ul>
<li>
<p><strong>定义</strong>：为发现错误而执行程序的过程。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p>挑剔性：测试只能证明程序有错误，不能证明无错误。</p>
</li>
<li>
<p>复杂性：输入空间、执行路径、并发状态极大。</p>
</li>
<li>
<p>不彻底性：无法穷尽所有情况。</p>
</li>
<li>
<p>经济性：在有限成本下尽可能暴露高价值缺陷。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-测试级别（V模型对应）">3 测试级别（V模型对应）</h2>
<ol>
<li>
<p>单元测试（Unit Testing）</p>
</li>
<li>
<p>集成测试（Integration Testing）</p>
</li>
<li>
<p>确认测试（Validation Testing）</p>
</li>
<li>
<p>系统测试（System Testing）</p>
</li>
<li>
<p>验收测试（Acceptance Testing）</p>
</li>
</ol>
<h2 id="4-测试方法分类">4 测试方法分类</h2>
<h3 id="4-1-静态分析（不执行程序）">4.1 静态分析（不执行程序）</h3>
<ol>
<li>
<p><strong>静态分析器</strong>：自动检查语法、类型、安全漏洞、编码规范。</p>
</li>
<li>
<p><strong>代码评审</strong>：走查（Walkthrough）、审查（Inspection）、结对评审。</p>
</li>
</ol>
<h3 id="4-2-动态测试（执行程序）">4.2 动态测试（执行程序）</h3>
<ol>
<li>
<p><strong>黑盒测试</strong>：基于需求规格，不关心内部结构。</p>
<ul>
<li>等价类划分、边界值分析、决策表、因果图、状态测试、场景测试。</li>
</ul>
</li>
<li>
<p><strong>白盒测试</strong>：基于程序内部逻辑结构。</p>
<ul>
<li>逻辑覆盖：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖。</li>
</ul>
</li>
</ol>
<h2 id="5-逻辑覆盖强度等级（由弱到强）">5 逻辑覆盖强度等级（由弱到强）</h2>
<ol>
<li>
<p>语句覆盖（Statement Coverage）</p>
</li>
<li>
<p>判定覆盖（Branch Coverage）</p>
</li>
<li>
<p>条件覆盖（Condition Coverage）</p>
</li>
<li>
<p>判定/条件覆盖（Branch/Condition Coverage）</p>
</li>
<li>
<p>条件组合覆盖（Multiple Condition Coverage）</p>
</li>
<li>
<p>路径覆盖（Path Coverage）</p>
</li>
</ol>
<h2 id="6-测试用例设计模板">6 测试用例设计模板</h2>
<ul>
<li>用例编号、测试项、优先级、前置条件、输入、操作步骤、预期结果、实际结果、是否通过、备注。</li>
</ul>
<h2 id="7-回归测试与自动化">7 回归测试与自动化</h2>
<ul>
<li>
<p>每次修改后重新执行已有测试，防止引入新缺陷。</p>
</li>
<li>
<p>对稳定模块编写自动化测试脚本（单元、接口、UI），形成持续集成流水线。</p>
</li>
</ul>
<h2 id="8-调试（Debugging）">8 调试（Debugging）</h2>
<ul>
<li>
<p>目标：定位并消除已发现错误的根源。</p>
</li>
<li>
<p>常用策略：断点、单步、打印日志、回溯分析、二分定位、因果推理。</p>
</li>
</ul>
<h2 id="9-测试交付物">9 测试交付物</h2>
<ul>
<li>
<p>测试计划（Test Plan）</p>
</li>
<li>
<p>测试用例与脚本（Test Case / Script）</p>
</li>
<li>
<p>缺陷报告（Bug Report）</p>
</li>
<li>
<p>测试总结报告（Test Summary Report）</p>
</li>
</ul>
<hr>
<p>当时还是2023年秋天。<br>
<img src="/images/IMG_20231209_163913.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/20/note_SE/" data-id="cuidRbO2fx_j06rDXIpbqtuAq" data-title="软件工程笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/20/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%BA%B2%E8%A6%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          概率论公式纲要
        
      </div>
    </a>
  
  
    <a href="/2025/10/18/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello , World</div>
    </a>
  
</nav>

  

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/20/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%BA%B2%E8%A6%81/">概率论公式纲要</a>
          </li>
        
          <li>
            <a href="/2025/10/20/note_SE/">软件工程笔记</a>
          </li>
        
          <li>
            <a href="/2025/10/18/hello-world/">Hello , World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>